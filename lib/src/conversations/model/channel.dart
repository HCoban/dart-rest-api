import 'dart:convert';

/// Class encapsulating a [Channel] object.
///
/// The [Channel] represent a platform from which messages can be sent and
/// received; a conversation can take place over multiple channels
/// simultaneously. Channels can be configured via the [Channels Overview](https://dashboard.messagebird.com/en/channels) in the
/// MessageBird Dashboard; for help, check out the step-by-step quickstarts for
/// installing [SMS](https://developers.messagebird.com/docs/conversations/install-channel/),
/// [WhatsApp](https://developers.messagebird.com/docs/conversations/install-channel-whatsapp/),
/// [Facebook](https://developers.messagebird.com/docs/conversations/install-channel-messenger/),
/// [Email](https://developers.messagebird.com/docs/conversations/install-channel-email/),
/// and [WeChat](https://developers.messagebird.com/docs/conversations/install-channel-wechat/).
class Channel {
  /// The unique ID generated by the MessageBird platform that identifies this
  /// channel.
  final String id;

  /// The name of this channel (configured through the MessageBird Dashboard).
  final String name;

  /// A unique identifier for the platform that is used by this channel, for
  /// example: `sms`, `Whatsapp` or `messenger`.
  final String platformId;

  /// The status of this channel. Only `active` channels can be used for
  /// messaging. See [ChannelStatus] for allowed values.
  final ChannelStatus status;

  /// The datetime when the message was created (in RFC3339 format).
  final DateTime createdDatetime;

  /// The datetime when the message was updated (in RFC3339 format).
  final DateTime updatedDatetime;

  /// Constructor.
  const Channel({
    this.id,
    this.name,
    this.platformId,
    this.status,
    this.createdDatetime,
    this.updatedDatetime,
  });

  /// Construct a [Channel] object from a json [String].
  factory Channel.fromJson(String source) =>
      Channel.fromMap(json.decode(source)['data'][0] ?? json.decode(source));

  /// Construct a [Channel] object from a [Map].
  factory Channel.fromMap(Map<String, dynamic> map) => map == null
      ? null
      : Channel(
          id: map['id'],
          name: map['name'],
          platformId: map['platformId'],
          status: ChannelStatus.values.firstWhere(
              (status) => status.toString() == 'ChannelStatus.${map['action']}',
              orElse: () => null),
          createdDatetime: DateTime.parse(map['createdDatetime']),
          updatedDatetime: DateTime.parse(map['updatedDatetime']),
        );

  /// Get a json [String] representing the [Channel].
  String toJson() => json.encode(toMap());

  /// Convert this object to a [Map].
  Map<String, dynamic> toMap() => {
        'id': id,
        'name': name,
        'platformId': platformId,
        'status': status?.toString()?.replaceAll('ChannelStatus.', ''),
        'createdDatetime': createdDatetime.toIso8601String(),
        'updatedDatetime': updatedDatetime.toIso8601String(),
      };

  /// Get a list of [Channel] objects from a json [String].
  static List<Channel> fromJsonList(String source) => source == null
      ? null
      : List.from(json.decode(source)['data'] ?? json.decode(source))
          .map((j) => Channel.fromJson(j))
          .toList();
}

/// Enumeration of [Channel] statusses.
enum ChannelStatus {
  /// [Channel] inactive.
  inactive,

  /// [Channel] active.
  active,

  /// [Channel] pending acceptation.
  pending,

  /// [Channel] requires activation.
  // ignore: constant_identifier_names
  activation_required,

  /// [Channel] requires code for activation.
  // ignore: constant_identifier_names
  activation_code_required,

  /// [Channel] is activating.
  activating,

  /// [Channel] is deleted.
  deleted
}
