import 'dart:convert';

import '../../util.dart';
import 'content.dart';

/// Class encapsulating a [Message] object.
///
/// Messages that have been sent by, or received from, a customer are
/// automatically threaded in a conversation. Any messages sent through the API
/// or received from your customer across any of your configured channels can be
/// retrieved via the messages endpoint. Messages are returned from the API in
/// the order they were created, with newest messages returned first. Certain
/// message types are channel specific such as a Highly Structured Message
/// (HSM), which are pre-approved message templates used by WhatsApp.
class Message {
  /// The unique ID generated by the MessageBird platform that identifies this
  /// message.
  final String id;

  /// The unique ID that identifies the conversation that this message is a part
  /// of.
  final String conversationId;

  /// The unique ID that identifies the channel that the message was sent or
  /// received on.
  final String channelId;

  /// A unique identifier for the platform that is used by this channel, for
  /// example: sms, whatsapp or messenger.
  final String platform;

  /// The unique ID that identifies the message recepient. The value depends on
  /// platform.
  final String to;

  /// The unique ID that identifies the message sender. The value depends on
  /// platform.
  final String from;

  /// The direction of the message. See [MessageDirection] for allowed values.
  final MessageDirection direction;

  /// The status of the message. See [MessageStatus] for allowed values.
  final MessageStatus status;

  /// The type of message content. See [MessageType] for allowed values.
  final MessageType type;

  /// Content of the message. The `type` field indicates the fields that will be
  /// populated in this object.
  final Content content;

  /// The datetime when the message was created (in RFC3339 format).
  final DateTime createdDatetime;

  /// The datetime when the message was updated (in RFC3339 format).
  final DateTime updatedDatetime;

  /// The source of the response/action that sent the message. An example of the
  /// source form: `{"agentId": "abc123", "userId": [1,2,3], "botId":`
  /// `1234567890}`
  final Map<String, dynamic> source;

  /// Constructor.
  const Message(
      {this.id,
      this.conversationId,
      this.channelId,
      this.platform,
      this.to,
      this.from,
      this.direction,
      this.status,
      this.type,
      this.content,
      this.createdDatetime,
      this.updatedDatetime,
      this.source});

  /// Construct a [Message] object from a json [String].
  factory Message.fromJson(String source) =>
      Message.fromMap((json.decode(source)['data'] != null)
          ? json.decode(source)['data'][0]
          : json.decode(source));

  /// Construct a [Message] object from a [Map].
  factory Message.fromMap(Map<String, dynamic> map) {
    final MessageType type = MessageType.values.firstWhere(
        (type) => type.toString() == 'MessageType.${map['type'].toString()}',
        orElse: () => null);
    return map == null
        ? null
        : Message(
            id: map['id'],
            conversationId: map['conversationId'],
            channelId: map['channelId'],
            platform: map['platform'],
            to: map['to'],
            from: map['from'],
            direction: MessageDirection.values.firstWhere(
                (direction) =>
                    direction.toString() ==
                    'MessageDirection.${map['direction'].toString()}',
                orElse: () => null),
            status: MessageStatus.values.firstWhere(
                (status) =>
                    status.toString() ==
                    'MessageStatus.${map['status'].toString()}',
                orElse: () => null),
            type: type,
            content: Content.fromMap(type, map['content']),
            createdDatetime: parseDate(map['createdDatetime']),
            updatedDatetime: parseDate(map['updatedDatetime']),
            source: map['source']);
  }

  /// Get a json [String] representing the [Message].
  String toJson() => json.encode(toMap());

  /// Construct a [Message] object from a [Map].
  Map<String, dynamic> toMap() => {
        'id': id,
        'conversationId': conversationId,
        'channelId': channelId,
        'platform': platform,
        'to': to,
        'from': from,
        'direction': direction?.toString()?.replaceAll('MessageDirection.', ''),
        'type': type?.toString()?.replaceAll('MessageType.', ''),
        'content': content.toMap(),
        'createdDatetime': createdDatetime?.toString(),
        'updatedDatetime': updatedDatetime?.toString(),
        'source': source
      };

  /// Get a list of [Message] objects from a json [String]
  static List<Message> fromJsonList(String source) => source == null
      ? null
      : ((json.decode(source).containsKey('totalCount') &&
                  json.decode(source)['totalCount'] == 0) ||
              json.decode(source).containsKey('pagination') &&
                  json.decode(source)['pagination']['totalCount'] == 0)
          ? <Message>[]
          : List<dynamic>.from(json.decode(source)['items'])
              .map((j) => Message.fromMap(j))
              .toList();
}

/// The direction of the message.
enum MessageDirection {
  /// Outbound message sent through the API.
  sent,

  /// Inbound message received from a customer.
  received
}

/// The status of the message.
enum MessageStatus {
  /// Message pending.
  pending,

  /// Message received.
  received,

  /// Message sent.
  sent,

  /// Message delivered.
  delivered,

  /// Message read.
  read,

  /// Message unsupported.
  unsupported,

  /// Message delivery failed.
  failed,

  /// Message deleted.
  deleted
}

/// The type of message content.
enum MessageType {
  /// Text message type.
  text,

  /// Image message type.
  image,

  /// Audio content type.
  audio,

  /// Video content type.
  video,

  /// Location content type.
  location,

  /// File content type.
  file,

  /// Highly Structured Message (HSM) content type. Only available for WhatsApp.
  hsm,

  /// Email content type.
  email
}
